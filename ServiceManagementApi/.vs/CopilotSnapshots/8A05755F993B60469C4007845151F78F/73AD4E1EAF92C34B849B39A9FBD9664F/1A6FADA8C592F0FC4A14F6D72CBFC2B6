using Microsoft.EntityFrameworkCore;
using ServiceManagementApi.Data;
using ServiceManagementApi.DTOs;
using ServiceManagementApi.Models;

namespace ServiceManagementApi.Services;

public interface ITechnicianService
{
    Task<TechnicianAvailabilityResponseDto> AddAvailabilityAsync(AvailabilityDto dto);
    Task<bool> RemoveAvailabilityAsync(int id, string technicianId);
    Task<List<TechnicianAvailabilityResponseDto>> GetAvailabilityAsync(string technicianId);

    // Scheduling (simple exact-time assign)
    Task<bool> ScheduleVisitAsync(ScheduleVisitDto dto);

    // Workload
    Task<TechnicianWorkloadDto> GetWorkloadAsync(string technicianId);
}

public class TechnicianService : ITechnicianService
{
    private readonly ApplicationDbContext _context;

    public TechnicianService(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<TechnicianAvailabilityResponseDto> AddAvailabilityAsync(AvailabilityDto dto)
    {
        if (dto.EndUtc <= dto.StartUtc) throw new ArgumentException("End must be after start");

        var avail = new TechnicianAvailability
        {
            TechnicianId = dto.TechnicianId,
            StartUtc = dto.StartUtc,
            EndUtc = dto.EndUtc
        };
        _context.TechnicianAvailabilities.Add(avail);
        await _context.SaveChangesAsync();

        return new TechnicianAvailabilityResponseDto
        {
            Id = avail.Id,
            TechnicianId = avail.TechnicianId,
            StartUtc = avail.StartUtc,
            EndUtc = avail.EndUtc
        };
    }

    public async Task<bool> RemoveAvailabilityAsync(int id, string technicianId)
    {
        var avail = await _context.TechnicianAvailabilities.FindAsync(id);
        if (avail == null || avail.TechnicianId != technicianId) return false;
        _context.TechnicianAvailabilities.Remove(avail);
        await _context.SaveChangesAsync();
        return true;
    }

    public async Task<List<TechnicianAvailabilityResponseDto>> GetAvailabilityAsync(string technicianId)
    {
        return await _context.TechnicianAvailabilities
            .Where(a => a.TechnicianId == technicianId)
            .OrderBy(a => a.StartUtc)
            .Select(a => new TechnicianAvailabilityResponseDto { Id = a.Id, TechnicianId = a.TechnicianId, StartUtc = a.StartUtc, EndUtc = a.EndUtc })
            .ToListAsync();
    }

    public async Task<bool> ScheduleVisitAsync(ScheduleVisitDto dto)
    {
        // simple: check there is an availability that includes the scheduled time and no exact-equal scheduled request exists
        var scheduled = dto.ScheduledUtc;

        var availExists = await _context.TechnicianAvailabilities
            .AnyAsync(a => a.TechnicianId == dto.TechnicianId && a.StartUtc <= scheduled && a.EndUtc >= scheduled);

        if (!availExists) return false;

        var conflict = await _context.ServiceRequests
            .AnyAsync(r => r.TechnicianId == dto.TechnicianId && r.ScheduledDate == scheduled && r.Status != RequestStatus.Completed);

        if (conflict) return false;

        var request = await _context.ServiceRequests.FindAsync(dto.ServiceRequestId);
        if (request == null) return false;

        request.TechnicianId = dto.TechnicianId;
        request.Status = RequestStatus.Assigned;
        request.ScheduledDate = dto.ScheduledUtc;

        await _context.SaveChangesAsync();
        return true;
    }

    public async Task<TechnicianWorkloadDto> GetWorkloadAsync(string technicianId)
    {
        var requests = await _context.ServiceRequests
            .Include(r => r.Category)
            .Where(r => r.TechnicianId == technicianId && r.Status == RequestStatus.Completed)
            .ToListAsync();

        double totalHours = 0;
        decimal totalEarnings = 0;

        foreach (var r in requests)
        {
            if (r.CompletedAt.HasValue)
            {
                totalHours += (r.CompletedAt.Value - r.CreatedAt).TotalHours;
            }
            else
            {
                totalHours += r.Category?.SlaHours ?? 0;
            }
        }

        var requestIds = requests.Select(r => r.Id).ToList();
        if (requestIds.Any())
        {
            var invoiceSum = await _context.Invoices
                .Where(i => requestIds.Contains(i.ServiceRequestId))
                .SumAsync(i => (decimal?)i.Amount) ?? 0m;

            if (invoiceSum > 0m)
            {
                totalEarnings = invoiceSum;
            }
            else
            {
                totalEarnings = requests.Sum(r => r.TotalPrice);
            }
        }

        List<object> monthly;
        if (requestIds.Any())
        {
            var invoicesList = await _context.Invoices
                .Where(i => requestIds.Contains(i.ServiceRequestId))
                .ToListAsync();

            var invoiceMonthly = invoicesList
                .GroupBy(i => new { i.GeneratedDate.Year, i.GeneratedDate.Month })
                .Select(g => new { month = new DateTime(g.Key.Year, g.Key.Month, 1).ToString("MMM yyyy"), total = g.Sum(i => i.Amount) })
                .OrderBy(x => x.month)
                .ToList<object>();

            if (invoiceMonthly.Any())
            {
                monthly = invoiceMonthly;
            }
            else
            {
                monthly = requests
                    .Where(r => r.CompletedAt.HasValue)
                    .GroupBy(r => new { Year = r.CompletedAt.Value.Year, Month = r.CompletedAt.Value.Month })
                    .Select(g => new { month = new DateTime(g.Key.Year, g.Key.Month, 1).ToString("MMM yyyy"), total = g.Sum(r => r.TotalPrice) })
                    .OrderBy(x => x.month)
                    .ToList<object>();
            }
        }
        else
        {
            monthly = new List<object>();
        }

        return new TechnicianWorkloadDto
        {
            TechnicianId = technicianId,
            TotalHoursWorked = Math.Round(totalHours, 1),
            TotalEarnings = totalEarnings,
            MonthlyEarnings = monthly
        };
    }
}
