using Microsoft.EntityFrameworkCore;
using ServiceManagementApi.Data;
using ServiceManagementApi.DTOs;
using ServiceManagementApi.Models;

namespace ServiceManagementApi.Services;

public interface ITechnicianService
{
    Task<TechnicianAvailabilityResponseDto> AddAvailabilityAsync(AvailabilityDto dto);
    Task<bool> RemoveAvailabilityAsync(int id, string technicianId);
    Task<List<TechnicianAvailabilityResponseDto>> GetAvailabilityAsync(string technicianId);

    // Scheduling
    Task<bool> ScheduleVisitAsync(ScheduleVisitDto dto);

    // Workload
    Task<TechnicianWorkloadDto> GetWorkloadAsync(string technicianId);
}

public class TechnicianService : ITechnicianService
{
    private readonly ApplicationDbContext _context;

    public TechnicianService(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<TechnicianAvailabilityResponseDto> AddAvailabilityAsync(AvailabilityDto dto)
    {
        if (dto.EndUtc <= dto.StartUtc) throw new ArgumentException("End must be after start");

        // stubbed: availability table removed earlier
        return new TechnicianAvailabilityResponseDto { Id = 0, TechnicianId = dto.TechnicianId, StartUtc = dto.StartUtc, EndUtc = dto.EndUtc };
    }

    public async Task<bool> RemoveAvailabilityAsync(int id, string technicianId)
    {
        return true;
    }

    public async Task<List<TechnicianAvailabilityResponseDto>> GetAvailabilityAsync(string technicianId)
    {
        return new List<TechnicianAvailabilityResponseDto>();
    }

    public async Task<bool> ScheduleVisitAsync(ScheduleVisitDto dto)
    {
        var request = await _context.ServiceRequests.FindAsync(dto.ServiceRequestId);
        if (request == null) return false;

        request.TechnicianId = dto.TechnicianId;
        request.Status = RequestStatus.Assigned;
        request.ScheduledDate = dto.ScheduledUtc;

        await _context.SaveChangesAsync();
        return true;
    }

    public async Task<TechnicianWorkloadDto> GetWorkloadAsync(string technicianId)
    {
        var requests = await _context.ServiceRequests
            .Include(r => r.Category)
            .Where(r => r.TechnicianId == technicianId)
            .OrderByDescending(r => r.CreatedAt)
            .ToListAsync();

        double totalHours = 0; decimal totalEarnings = 0;
        var completed = requests.Where(r => r.Status == RequestStatus.Completed).ToList();

        // Calculate total hours based on Category.SlaHours (installation=4, repair=3, maintenance=2)
        foreach (var r in completed)
        {
            totalHours += r.Category?.SlaHours ?? 0;
        }

        var requestIds = completed.Select(r => r.Id).ToList();
        if (requestIds.Any())
        {
            var invoiceSum = await _context.Invoices.Where(i => requestIds.Contains(i.ServiceRequestId)).SumAsync(i => (decimal?)i.Amount) ?? 0m;
            if (invoiceSum > 0m) totalEarnings = invoiceSum; else totalEarnings = completed.Sum(r => r.TotalPrice);
        }

        // load customer user names for the requests in one query
        var customerIds = requests.Where(r => !string.IsNullOrEmpty(r.CustomerId)).Select(r => r.CustomerId!).Distinct().ToList();
        var customers = await _context.Users.Where(u => customerIds.Contains(u.Id)).ToDictionaryAsync(u => u.Id, u => u.UserName);

        // build previous tasks DTOs (include recent tasks regardless of status)
        var previousTasks = requests.Select(r => new TechnicianTaskDto
        {
            RequestId = r.Id,
            IssueDescription = r.IssueDescription,
            ScheduledDate = r.ScheduledDate,
            CompletedAt = r.CompletedAt,
            TotalPrice = r.TotalPrice,
            Status = r.Status.ToString(),
            CustomerId = r.CustomerId,
            CustomerName = r.CustomerId != null && customers.ContainsKey(r.CustomerId) ? customers[r.CustomerId] : null
        }).ToList();

        return new TechnicianWorkloadDto { TechnicianId = technicianId, TotalHoursWorked = Math.Round(totalHours,1), TotalEarnings = totalEarnings, MonthlyEarnings = new List<object>(), PreviousTasks = previousTasks };
    }
}
