using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using ServiceManagementApi.DTOs;
using ServiceManagementApi.Models;
using ServiceManagementApi.Services;
using System.Security.Claims;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class ServiceRequestController : ControllerBase
{
    private readonly IServiceRequestService _service;

    public ServiceRequestController(IServiceRequestService service)
    {
        _service = service;
    }

    [HttpGet("categories")]
    public async Task<IActionResult> GetCategories() => Ok(await _service.GetCategoriesAsync());

    [HttpPost("create")]
    [Authorize(Roles = "Customer")]
    public async Task<IActionResult> Create(CreateRequestDto dto)
    {
        await _service.CreateRequestAsync(dto, User.FindFirstValue(ClaimTypes.NameIdentifier)!);
        return Ok(new { message = "Success" });
    }

    [HttpPut("update-status")]
    public async Task<IActionResult> UpdateStatus(UpdateStatusDto dto)
    {
        var success = await _service.UpdateStatusWithBillingAsync(dto);
        return success ? Ok() : NotFound();
    }

    [HttpGet("monitor-all")]
    [Authorize(Roles = "Manager,Admin")]
    public async Task<IActionResult> Monitor() => Ok(await _service.GetAllForMonitorAsync());

    [HttpPut("assign")]
    [Authorize(Roles = "Manager,Admin")]
    public async Task<IActionResult> Assign(AssignTechnicianDto dto)
    {
        var success = await _service.AssignTechnicianAsync(dto);
        return success ? Ok() : NotFound();
    }


    [Authorize(Roles = "Technician")]
    [HttpGet("my-tasks")]
    public async Task<IActionResult> GetMyTasks()
    {
        // Get the ID of the logged-in technician from the JWT token
        var technicianId = User.FindFirstValue(ClaimTypes.NameIdentifier);

        if (string.IsNullOrEmpty(technicianId)) return Unauthorized();

        // Call the service instead of the context directly
        var tasks = await _service.GetTechnicianTasksAsync(technicianId);

        return Ok(tasks);
    }

    [Authorize(Roles = "Customer")]
    [HttpGet("my-requests")]
    public async Task<IActionResult> GetMyRequests()
    {
        var userId = User.FindFirstValue(ClaimTypes.NameIdentifier);
        var requests = await _service.GetCustomerRequestsAsync(userId);
        return Ok(requests);
    }

    [HttpGet("dashboard-stats")]
    [Authorize(Roles = "Admin,Manager")]
    public async Task<IActionResult> GetStats()
    {
        var result = await _service.GetDashboardStatsAsync();
        return Ok(result);
    }

    // Allow technician to accept/reject an assignment
    [Authorize(Roles = "Technician")]
    [HttpPost("{id}/respond")]
    public async Task<IActionResult> Respond(int id, [FromBody] bool accept)
    {
        var techId = User.FindFirstValue(ClaimTypes.NameIdentifier); // Get current Tech ID from JWT
        var result = await _service.RespondToAssignmentAsync(id, techId, accept);

        if (!result) return BadRequest("Could not process response.");
        return Ok(new { message = accept ? "Task Accepted" : "Task Rejected" });
    }

    // Customers (and Managers/Admins via role) can reschedule. Service enforces ownership/permissions.
    [HttpPatch("{id}/reschedule")]
    [Authorize]
    public async Task<IActionResult> Reschedule(int id, [FromBody] DateTime newDate)
    {
        var userId = User.FindFirstValue(ClaimTypes.NameIdentifier);
        var userRole = User.FindFirstValue(ClaimTypes.Role) ?? string.Empty;

        var success = await _service.RescheduleRequestAsync(id, newDate, userId, userRole);

        if (!success) return BadRequest("Could not reschedule. Technician may be unavailable or unauthorized.");
        return Ok(new { message = "Appointment rescheduled successfully." });
    }

    [HttpDelete("{id}/cancel")]
    [Authorize(Roles = "Customer")]
    public async Task<IActionResult> CancelRequest(int id)
    {
        // Get the User ID from the JWT Token
        var userId = User.FindFirstValue(ClaimTypes.NameIdentifier);

        var result = await _service.CancelRequestAsync(id, userId);

        if (!result)
            return BadRequest("Unable to cancel. Request not found or technician already started work.");

        return Ok(new { message = "Service request cancelled successfully." });
    }


}