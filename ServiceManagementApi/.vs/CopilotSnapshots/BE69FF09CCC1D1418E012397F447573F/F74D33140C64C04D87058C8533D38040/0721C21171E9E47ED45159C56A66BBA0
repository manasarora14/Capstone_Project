using Microsoft.EntityFrameworkCore;
using ServiceManagementApi.Data;
using ServiceManagementApi.DTOs;
using ServiceManagementApi.Models;

namespace ServiceManagementApi.Services;

public interface ITechnicianService
{
    Task<TechnicianAvailabilityResponseDto> AddAvailabilityAsync(AvailabilityDto dto);
    Task<bool> RemoveAvailabilityAsync(int id, string technicianId);
    Task<List<TechnicianAvailabilityResponseDto>> GetAvailabilityAsync(string technicianId);

    // Scheduling
    Task<bool> ScheduleVisitAsync(ScheduleVisitDto dto);

    // Workload
    Task<TechnicianWorkloadDto> GetWorkloadAsync(string technicianId);
}

public class TechnicianService : ITechnicianService
{
    private readonly ApplicationDbContext _context;

    public TechnicianService(ApplicationDbContext context)
    {
        _context = context;
    }

    public async Task<TechnicianAvailabilityResponseDto> AddAvailabilityAsync(AvailabilityDto dto)
    {
        if (dto.EndUtc <= dto.StartUtc) throw new ArgumentException("End must be after start");

        // stubbed: availability table removed earlier
        return new TechnicianAvailabilityResponseDto { Id = 0, TechnicianId = dto.TechnicianId, StartUtc = dto.StartUtc, EndUtc = dto.EndUtc };
    }

    public async Task<bool> RemoveAvailabilityAsync(int id, string technicianId)
    {
        return true;
    }

    public async Task<List<TechnicianAvailabilityResponseDto>> GetAvailabilityAsync(string technicianId)
    {
        return new List<TechnicianAvailabilityResponseDto>();
    }

    public async Task<bool> ScheduleVisitAsync(ScheduleVisitDto dto)
    {
        var request = await _context.ServiceRequests.FindAsync(dto.ServiceRequestId);
        if (request == null) return false;

        request.TechnicianId = dto.TechnicianId;
        request.Status = RequestStatus.Assigned;
        request.ScheduledDate = dto.ScheduledUtc;

        await _context.SaveChangesAsync();
        return true;
    }

    public async Task<TechnicianWorkloadDto> GetWorkloadAsync(string technicianId)
    {
        var requests = await _context.ServiceRequests
            .Include(r => r.Category)
            .Where(r => r.TechnicianId == technicianId)
            .OrderByDescending(r => r.CreatedAt)
            .ToListAsync();

        double totalHours = 0; decimal totalEarnings = 0;
        // Include both Completed and Closed requests for earnings and hours
        var doneRequests = requests.Where(r => r.Status == RequestStatus.Completed || r.Status == RequestStatus.Closed).ToList();

        // Calculate total hours based strictly on WorkStartedAt -> WorkEndedAt for done requests
        foreach (var r in doneRequests)
        {
            if (r.WorkStartedAt.HasValue && r.WorkEndedAt.HasValue)
            {
                var duration = (r.WorkEndedAt.Value - r.WorkStartedAt.Value).TotalHours;
                totalHours += Math.Max(0.0, duration);
            }
        }

        // Calculate earnings: prefer ServiceRequest.TotalPrice when set; otherwise use invoice amount if present
        var requestIds = doneRequests.Select(r => r.Id).ToList();
        if (requestIds.Any())
        {
            var invoices = await _context.Invoices
                .Where(i => requestIds.Contains(i.ServiceRequestId))
                .ToDictionaryAsync(i => i.ServiceRequestId, i => i.Amount);

            totalEarnings = doneRequests.Sum(r =>
                r.TotalPrice != 0m ? r.TotalPrice : (invoices.TryGetValue(r.Id, out var amt) ? amt : 0m)
            );
        }

        // load customer user names for the requests in one query
        var customerIds = requests.Where(r => !string.IsNullOrEmpty(r.CustomerId)).Select(r => r.CustomerId!).Distinct().ToList();
        var customers = await _context.Users.Where(u => customerIds.Contains(u.Id)).ToDictionaryAsync(u => u.Id, u => u.UserName);

        // build previous tasks DTOs (include recent tasks regardless of status)
        var previousTasks = requests.Select(r => new TechnicianTaskDto
        {
            RequestId = r.Id,
            IssueDescription = r.IssueDescription,
            ScheduledDate = r.ScheduledDate,
            CompletedAt = r.CompletedAt,
            TotalPrice = r.TotalPrice,
            Status = r.Status.ToString(),
            CustomerId = r.CustomerId,
            CustomerName = r.CustomerId != null && customers.ContainsKey(r.CustomerId) ? customers[r.CustomerId] : null
        }).ToList();

        return new TechnicianWorkloadDto { TechnicianId = technicianId, TotalHoursWorked = Math.Round(totalHours,1), TotalEarnings = totalEarnings, MonthlyEarnings = new List<object>(), PreviousTasks = previousTasks };
    }
}
