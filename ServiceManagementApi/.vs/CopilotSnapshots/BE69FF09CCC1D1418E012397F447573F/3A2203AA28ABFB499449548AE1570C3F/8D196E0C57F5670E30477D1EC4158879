using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using ServiceManagementApi.DTOs;
using ServiceManagementApi.Models;
using ServiceManagementApi.Services;
using System.Security.Claims;

[Route("api/[controller]")]
[ApiController]
[Authorize]
public class ServiceRequestController : ControllerBase
{
    private readonly IServiceRequestService _service;
    private readonly IAvailabilityService _availabilityService;

    public ServiceRequestController(IServiceRequestService service, IAvailabilityService availabilityService)
    {
        _service = service;
        _availabilityService = availabilityService;
    }

    [HttpGet("categories")]
    public async Task<IActionResult> GetCategories() => Ok(await _service.GetCategoriesAsync());

    [HttpPost("create")]
    [Authorize(Roles = "Customer")]
    public async Task<IActionResult> Create(CreateRequestDto dto)
    {
        await _service.CreateRequestAsync(dto, User.FindFirstValue(ClaimTypes.NameIdentifier)!);
        return Ok(new { message = "Success" });
    }

    [HttpPut("update-status")]
    public async Task<IActionResult> UpdateStatus(UpdateStatusDto dto)
    {
        var success = await _service.UpdateStatusWithBillingAsync(dto);
        return success ? Ok() : NotFound();
    }

    [HttpGet("monitor-all")]
    [Authorize(Roles = "Manager,Admin")]
    public async Task<IActionResult> Monitor() => Ok(await _service.GetAllForMonitorAsync());

    [HttpPut("assign")]
    [Authorize(Roles = "Manager,Admin")]
    public async Task<IActionResult> Assign(AssignTechnicianDto dto)
    {
        var success = await _service.AssignTechnicianAsync(dto);
        if (!success)
        {
            return BadRequest(new { message = "Technician is not available for the scheduled time slot or request not found." });
        }
        return Ok(new { message = "Technician assigned successfully" });
    }

    [HttpGet("available-technicians/{requestId}")]
    [Authorize(Roles = "Manager,Admin")]
    public async Task<IActionResult> GetAvailableTechniciansForRequest(int requestId)
    {
        var request = await _service.GetServiceRequestByIdAsync(requestId, "", "Admin");
        if (request == null) return NotFound();

        var scheduledStart = request.PlannedStartUtc ?? request.ScheduledDate;
        var duration = request.Category?.SlaHours ?? 0;

        if (duration <= 0)
        {
            return BadRequest(new { message = "Request does not have a valid category SLA duration" });
        }

        var availableTechs = await _availabilityService.GetAvailableTechniciansAsync(scheduledStart, duration);
        
        return Ok(availableTechs);
    }


    [Authorize(Roles = "Technician")]
    [HttpGet("my-tasks")]
    public async Task<IActionResult> GetMyTasks()
    {
        // Get the ID of the logged-in technician from the JWT token
        var technicianId = User.FindFirstValue(ClaimTypes.NameIdentifier);

        if (string.IsNullOrEmpty(technicianId)) return Unauthorized();

        // Call the service instead of the context directly
        var tasks = await _service.GetTechnicianTasksAsync(technicianId);

        return Ok(tasks);
    }

    [Authorize(Roles = "Customer")]
    [HttpGet("my-requests")]
    public async Task<IActionResult> GetMyRequests()
    {
        var userId = User.FindFirstValue(ClaimTypes.NameIdentifier);
        var requests = await _service.GetCustomerRequestsAsync(userId);
        return Ok(requests);
    }

    [HttpGet("dashboard-stats")]
    [Authorize(Roles = "Admin,Manager")]
    public async Task<IActionResult> GetStats()
    {
        var result = await _service.GetDashboardStatsAsync();
        return Ok(result);
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> GetServiceRequestById(int id)
    {
        var userId = User.FindFirstValue(ClaimTypes.NameIdentifier);
        var userRole = User.FindFirstValue(ClaimTypes.Role) ?? string.Empty;

        if (string.IsNullOrEmpty(userId)) return Unauthorized();

        var request = await _service.GetServiceRequestByIdAsync(id, userId, userRole);
        
        if (request == null) return NotFound();

        return Ok(request);
    }

    // Allow technician to accept/reject an assignment (supports planned start)
    [Authorize(Roles = "Technician")]
    [HttpPost("{id}/respond")]
    public async Task<IActionResult> Respond(int id, [FromBody] RespondAssignmentDto? dto)
    {
        var techId = User.FindFirstValue(ClaimTypes.NameIdentifier); // Get current Tech ID from JWT

        bool accept;
        DateTime? planned = null;

        if (dto == null)
        {
            return BadRequest("Invalid payload");
        }

        accept = dto.Accept;
        planned = dto.PlannedStartUtc;

        var result = await _service.RespondToAssignmentAsync(id, techId, accept, planned);

        if (!result) return BadRequest("Could not process response.");
        return Ok(new { message = accept ? "Task Accepted" : "Task Rejected" });
    }

    // Customers (and Managers/Admins via role) can reschedule. Service enforces ownership/permissions.
    [HttpPut("reschedule")]
    [Authorize]
    public async Task<IActionResult> Reschedule([FromBody] RescheduleDto dto)
    {
        var userId = User.FindFirstValue(ClaimTypes.NameIdentifier);
        var userRole = User.FindFirstValue(ClaimTypes.Role) ?? string.Empty;

        var success = await _service.RescheduleRequestAsync(dto.Id, dto.NewDate, userId, userRole);

        if (!success) return BadRequest("Could not reschedule. Technician may be unavailable or unauthorized.");
        return Ok(new { message = "Appointment rescheduled successfully." });
    }

    [HttpDelete("{id}/cancel")]
    [Authorize(Roles = "Customer")]
    public async Task<IActionResult> CancelRequest(int id)
    {
        // Get the User ID from the JWT Token
        var userId = User.FindFirstValue(ClaimTypes.NameIdentifier);

        var result = await _service.CancelRequestAsync(id, userId);

        if (!result)
            return BadRequest("Unable to cancel. Request not found or technician already started work.");

        return Ok(new { message = "Service request cancelled successfully." });
    }

    // Technician marks start of work
    [Authorize(Roles = "Technician")]
    [HttpPost("{id}/start")]
    public async Task<IActionResult> StartWork(int id)
    {
        var techId = User.FindFirstValue(ClaimTypes.NameIdentifier);
        var now = DateTime.UtcNow;
        var ok = await _service.StartWorkAsync(id, techId, now);
        return ok ? Ok(new { message = "Work started", startedAt = now }) : BadRequest("Unable to start work.");
    }

    // Technician finishes work
    [Authorize(Roles = "Technician")]
    [HttpPost("{id}/finish")]
    public async Task<IActionResult> FinishWork(int id)
    {
        var techId = User.FindFirstValue(ClaimTypes.NameIdentifier);
        var now = DateTime.UtcNow;
        var ok = await _service.FinishWorkAsync(id, techId, now);
        return ok ? Ok(new { message = "Work finished", finishedAt = now }) : BadRequest("Unable to finish work.");
    }

}